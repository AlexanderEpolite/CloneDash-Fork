# This workflow will build a .NET project
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-net
name: Build Release
on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    strategy:
      matrix:
        os:
          - windows-latest
          - ubuntu-latest
          - macos-latest
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4
      
      - name: Create Directory.Build.props to suppress NU1605
        shell: bash
        run: |
          cat > Directory.Build.props <<'EOF'
          <Project>
            <PropertyGroup>
              <RestoreNoWarn>$(RestoreNoWarn);NU1605</RestoreNoWarn>
              <NoWarn>$(NoWarn);NU1605</NoWarn>
            </PropertyGroup>
          </Project>
          EOF
      
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x
      
      - name: Restore dependencies
        run: dotnet restore ./CloneDash.sln -p:RestoreNoWarn=NU1605
      
      - name: Build (Release)
        run: dotnet build ./CloneDash.sln --configuration Release --no-restore
      
      - name: Publish Windows single-file exe (framework-dependent)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          dotnet publish "./CloneDash" `
            -c Release `
            -f net8.0 `
            -r win-x64 `
            -p:SelfContained=false `
            -p:PublishSingleFile=true `
            -p:UseAppHost=true `
            -p:RestoreNoWarn=NU1605 `
            -o "./publish/win-x64-single"
          $exe = Get-ChildItem -Path "./publish/win-x64-single" -Filter *.exe | Select-Object -First 1
          if (-not $exe) { throw "No exe produced in ./publish/win-x64-single" }
          Copy-Item $exe.FullName "./CloneDash-Game-Windows-Portable.exe" -Force
      
      - name: Zip for Release (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $tempDir = "tempzip"
          Remove-Item -Recurse -Force $tempDir -ErrorAction SilentlyContinue
          New-Item -ItemType Directory -Path $tempDir | Out-Null
          Copy-Item -Recurse -Force "./CloneDash/bin/Release/net8.0/*" $tempDir
          Copy-Item -Recurse -Force "./Nucleus.ModelEditor/bin/Release/net8.0/*" $tempDir
          Compress-Archive -Path "$tempDir\*" -DestinationPath "./CloneDash-Game-Windows.zip" -Force
          Remove-Item -Recurse -Force $tempDir
      
      # Build AppImage directly from the same bin output as the working ZIP,
      # but run the app from a writable per-user directory at runtime so files like mdlut.dat
      # can be created or found reliably.
      - name: Build AppImage (Linux)
        if: matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          set -euo pipefail
          APPDIR=AppDir
          rm -rf "$APPDIR"
          mkdir -p "$APPDIR/usr/bin"
          
          # Copy exactly what the ZIP uses so assets match
          cp -a "./CloneDash/bin/Release/net8.0/." "$APPDIR/usr/bin/"
          # Include any shared/editor assets if they are used at runtime
          if [ -d "./Nucleus.ModelEditor/bin/Release/net8.0" ]; then
            cp -a "./Nucleus.ModelEditor/bin/Release/net8.0/." "$APPDIR/usr/bin/" || true
          fi
          
          # Ensure main executable(s) are executable when present
          [ -f "$APPDIR/usr/bin/CloneDash" ] && chmod +x "$APPDIR/usr/bin/CloneDash" || true
          [ -f "$APPDIR/usr/bin/Clone Dash" ] && chmod +x "$APPDIR/usr/bin/Clone Dash" || true
          
          echo "== Listing key files in AppImage payload =="
          (cd "$APPDIR/usr/bin" && ls -la | sed -n '1,200p') || true
          echo "== Searching for mdlut.dat in payload =="
          find "$APPDIR/usr/bin" -maxdepth 6 -type f -iname 'mdlut.dat' -printf '%p\n' || true
          
          # AppRun: copy payload to a writable per-user dir and run from there.
          # This avoids failures when the game tries to create or update files like mdlut.dat.
          cat > "$APPDIR/AppRun" << 'EOF'
          #!/bin/sh
          set -eu
          
          # Resolve payload dir inside the mounted AppImage
          HERE="$(dirname "$(readlink -f "$0")")"
          PAYLOAD="$HERE/usr/bin"
          
          # Ensure native libs in usr/bin are discoverable
          export LD_LIBRARY_PATH="$PAYLOAD${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}"
          
          # Choose a writable run dir for the user
          APPNAME="CloneDash"
          if [ -n "${HOME:-}" ]; then
            DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
            RUN_DIR="$DATA_HOME/$APPNAME/AppImageRun"
          else
            # Fallback to /tmp if HOME is not set
            RUN_DIR="/tmp/${APPNAME}-run"
          fi
          mkdir -p "$RUN_DIR"
          
          # Sync payload into the writable run dir (idempotent)
          # cp -a preserves permissions, times, symlinks
          cp -a "$PAYLOAD/." "$RUN_DIR/"
          
          # Quality-of-life: place/alias mdlut.dat in common lookup spots
          if [ -f "$RUN_DIR/Compatibility/MuseDash/mdlut.dat" ] && [ ! -e "$RUN_DIR/mdlut.dat" ]; then
            ln -sf "Compatibility/MuseDash/mdlut.dat" "$RUN_DIR/mdlut.dat"
          fi
          if [ -n "${HOME:-}" ] && [ -f "$RUN_DIR/mdlut.dat" ]; then
            CONF_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/$APPNAME"
            DATA_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/$APPNAME"
            mkdir -p "$CONF_DIR" "$DATA_DIR" || true
            [ ! -f "$CONF_DIR/mdlut.dat" ] && cp -f "$RUN_DIR/mdlut.dat" "$CONF_DIR/mdlut.dat" || true
            [ ! -f "$DATA_DIR/mdlut.dat" ] && cp -f "$RUN_DIR/mdlut.dat" "$DATA_DIR/mdlut.dat" || true
          fi
          
          # Run from the writable directory so relative asset paths and generated files work
          cd "$RUN_DIR"
          
          # Prefer native host; otherwise use dotnet if only DLL is present
          if [ -x "./CloneDash" ]; then
            exec "./CloneDash" "$@"
          elif [ -x "./Clone Dash" ]; then
            exec "./Clone Dash" "$@"
          elif [ -f "./CloneDash.dll" ]; then
            exec dotnet "./CloneDash.dll" "$@"
          else
            CANDIDATE="$(find . -maxdepth 1 -type f -perm -111 | head -n1 || true)"
            if [ -z "$CANDIDATE" ]; then
              echo "No executable found in $RUN_DIR" >&2
              exit 1
            fi
            exec "$CANDIDATE" "$@"
          fi
          EOF
          chmod +x "$APPDIR/AppRun"
          
          cat > "$APPDIR/CloneDash.desktop" << 'EOF'
          [Desktop Entry]
          Type=Application
          Name=CloneDash
          Comment=CloneDash Game
          Exec=AppRun %F
          Icon=CloneDash
          Categories=Game;
          Terminal=false
          EOF
          
          # Minimal placeholder icon
          base64 -d > "$APPDIR/CloneDash.png" << 'EOF'
          iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8Xw8AAvoB9B9l60wAAAAASUVORK5CYII=
          EOF
          ln -sf CloneDash.png "$APPDIR/.DirIcon"
          
          # Build AppImage without requiring FUSE on the runner
          curl -fsSL -o appimagetool-x86_64.AppImage https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
          chmod +x appimagetool-x86_64.AppImage
          ./appimagetool-x86_64.AppImage --appimage-extract
          ARCH=x86_64 ./squashfs-root/AppRun "$APPDIR"
          
          # Normalize output filename
          mv CloneDash-*.AppImage ./CloneDash-Game-Linux.AppImage 2>/dev/null || \
          mv AppDir-*.AppImage ./CloneDash-Game-Linux.AppImage
      
      - name: Zip for Release (Linux)
        if: matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          set -e
          rm -rf tempzip
          mkdir -p tempzip
          cp -r "./CloneDash/bin/Release/net8.0/"* tempzip/
          cp -r "./Nucleus.ModelEditor/bin/Release/net8.0/"* tempzip/
          zip -r "./CloneDash-Game-Linux.zip" tempzip
          rm -rf tempzip
      
      - name: Zip for Release (macOS)
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          set -e
          rm -rf tempzip
          mkdir -p tempzip
          cp -r "./CloneDash/bin/Release/net8.0/"* tempzip/
          cp -r "./Nucleus.ModelEditor/bin/Release/net8.0/"* tempzip/
          zip -r "./CloneDash-Game-macOS.zip" tempzip
          rm -rf tempzip
      
      - name: Upload artifact - Windows zip
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: CloneDash-Game-Windows
          path: ./CloneDash-Game-Windows.zip
          if-no-files-found: error
      
      - name: Upload artifact - Windows Portable exe
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: CloneDash-Game-Windows-Portable
          path: ./CloneDash-Game-Windows-Portable.exe
          if-no-files-found: error
      
      - name: Upload artifact - Linux zip
        if: matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v4
        with:
          name: CloneDash-Game-Linux
          path: ./CloneDash-Game-Linux.zip
          if-no-files-found: error
      
      - name: Upload artifact - Linux AppImage
        if: matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v4
        with:
          name: CloneDash-Game-Linux-AppImage
          path: ./CloneDash-Game-Linux.AppImage
          if-no-files-found: error
      
      - name: Upload artifact - macOS zip
        if: matrix.os == 'macos-latest'
        uses: actions/upload-artifact@v4
        with:
          name: CloneDash-Game-macOS
          path: ./CloneDash-Game-macOS.zip
          if-no-files-found: error
  
  release:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./dist
      
      - name: Compute short SHA tag
        id: meta
        shell: bash
        run: |
          SHORT="${GITHUB_SHA::7}"
          echo "tag=$SHORT" >> "$GITHUB_OUTPUT"
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.meta.outputs.tag }}
          fail_on_unmatched_files: true
          files: |
            dist/CloneDash-Game-Windows/CloneDash-Game-Windows.zip
            dist/CloneDash-Game-Windows-Portable/CloneDash-Game-Windows-Portable.exe
            dist/CloneDash-Game-Linux/CloneDash-Game-Linux.zip
            dist/CloneDash-Game-Linux-AppImage/CloneDash-Game-Linux.AppImage
            dist/CloneDash-Game-macOS/CloneDash-Game-macOS.zip